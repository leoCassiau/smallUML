-- @path MM=/SmallUML/model/smalluml.ecore
-- @path MM1=/UML/model/uml.ecore

module Small2UML;
create OUT : MM1 from IN : MM;

rule Root2Package {
	from
		s: MM!Root
	to
		t: MM1!Package (
			packagedElement <- (s.primitiveTypes->collect(p | thisModule.Type2PrimitiveType(p)))
				.union(s.elements->collect(c | thisModule.Class2Class(c)))
		)
}

lazy rule Class2Class {
	from
		s: MM!Class
	to
		t: MM1!Class (
			name <- s.name,
			--superClass <- s.superClass->collect(sc | thisModule.Type2Type(sc)),
			ownedAttribute <- s.ownedProperties->collect(p | thisModule.Property2Property(p)),
			ownedOperation <- s.ownedOperations->collect(o | thisModule.Operation2Operation(o))
		)
}

lazy rule Property2Property {
	from 
		s: MM!Property
	to
		t: MM1!Property (
			name <- s.name,
			upper <- s.upperBound,
			lower <- s.lowerBound,
			type <- if  s.type.oclIsTypeOf(MM!Class)
				then thisModule.Class2Class(s.type)
				else thisModule.Type2PrimitiveType(s.type) 
				endif
		)
}

lazy rule Operation2Operation {
	from
		s: MM!Operation
	to
		t: MM1!Operation (
			name <- s.name,
			--type <- if s.resultType.oclIsTypeOf(MM!Class) then thisModule.Class2Class(s.resultType) else thisModule.Type2PrimitiveType(s.resultType) endif ,
			ownedParameter <- s.params->collect(p | thisModule.Type2Parameter(p)) 
		)
}

lazy rule Type2Parameter {
	from
		s: MM!Type
	to
		t: MM1!Parameter (
			name <- 'param',
			type <- s
		)	
}

lazy rule Type2PrimitiveType {
	from
		s: MM!Type
	to
		t: MM1!PrimitiveType (
			name <- if s.oclIsTypeOf(MM!TypeString) then 'String' else
						if s.oclIsTypeOf(MM!TypeBoolean) then 'Boolean' else
							if s.oclIsTypeOf(MM!TypeInteger) then 'Integer' else
								if s.oclIsTypeOf(MM!TypeReal) then 'Real' else 
									'UnlimitedNatural'
								endif
							endif
						endif
					endif
		)
}
	